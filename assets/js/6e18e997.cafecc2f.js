"use strict";(self.webpackChunkstarknet_docs=self.webpackChunkstarknet_docs||[]).push([[75],{3905:function(e,t,a){a.d(t,{Zo:function(){return h},kt:function(){return u}});var n=a(7294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},h=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,r=e.originalType,c=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),m=l(a),u=s,p=m["".concat(c,".").concat(u)]||m[u]||d[u]||r;return a?n.createElement(p,o(o({ref:t},h),{},{components:a})):n.createElement(p,o({ref:t},h))}));function u(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=a.length,o=new Array(r);o[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:s,o[1]=i;for(var l=2;l<r;l++)o[l]=a[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},5565:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return h},default:function(){return m}});var n=a(7462),s=a(3366),r=(a(7294),a(3905)),o=["components"],i={},c="Messaging Mechanism",l={unversionedId:"L1<>L2 Communication/messaging-mechanism",id:"L1<>L2 Communication/messaging-mechanism",title:"Messaging Mechanism",description:"L1 \u2192 L2 Messages",source:"@site/docs/L1<>L2 Communication/messaging-mechanism.md",sourceDirName:"L1<>L2 Communication",slug:"/L1<>L2 Communication/messaging-mechanism",permalink:"/docs/L1<>L2 Communication/messaging-mechanism",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/L1<>L2 Communication/messaging-mechanism.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Fee Mechanism",permalink:"/docs/Fees/fee-mechanism"},next:{title:"StarkGate \u2013 Token Bridge",permalink:"/docs/L1<>L2 Communication/token-bridge"}},h=[{value:"L1 \u2192 L2 Messages",id:"l1--l2-messages",children:[],level:2},{value:"L2 \u2192 L1 Messages",id:"l2--l1-messages",children:[],level:2},{value:"L1 \u2192 L2 Message Cancellation",id:"l1--l2-message-cancellation",children:[],level:2}],d={toc:h};function m(e){var t=e.components,i=(0,s.Z)(e,o);return(0,r.kt)("wrapper",(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"messaging-mechanism"},"Messaging Mechanism"),(0,r.kt)("h2",{id:"l1--l2-messages"},"L1 \u2192 L2 Messages"),(0,r.kt)("p",null,"Contracts on L1 can interact asynchronously with contracts on L2 via the L1\u2192L2 messaging protocol. In the first step, an L1 contract initiates a message to an L2 contract on StarkNet. It does so by calling the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/starkware-libs/cairo-lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/StarknetMessaging.sol#L100"},(0,r.kt)("inlineCode",{parentName:"a"},"sendMessageToL2"))," function on the StarkNet Core Contract with the message parameters. The StarkNet Core Contract hashes the message parameters (the L1 sender address, the recipient contract address on StarkNet, function selector, and the relevant calldata) and increases the hash counter by 1."),(0,r.kt)("p",null,"A message is then decoded into a StarkNet transaction which invokes a function annotated with the ",(0,r.kt)("inlineCode",{parentName:"p"},"l1_handler")," decorator on the target contract.\nThe StarkNet sequencer, upon seeing enough L1 confirmations for the transaction that sent the message, initiates the corresponding L2 transaction which invokes the relevant ",(0,r.kt)("inlineCode",{parentName:"p"},"l1_handler"),". The handled message is then attached to the proof of the relevant state update \u2013 and the message is cleared (or the count is deduced) when the state is updated. At this point the message is considered handled."),(0,r.kt)("p",null,"The above flow is illustrated in the following diagram:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"l1l2",src:a(3457).Z})),(0,r.kt)("h2",{id:"l2--l1-messages"},"L2 \u2192 L1 Messages"),(0,r.kt)("p",null,"Contracts on L2 can interact asynchronously with contracts on L1 via the L2\u2192L1 messaging protocol."),(0,r.kt)("p",null,"During the execution of a StarkNet transaction, a contract on StarkNet sends an L2\u2192L1 message by calling the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/starkware-libs/cairo-lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/common/messages.cairo#L4"},(0,r.kt)("inlineCode",{parentName:"a"},"send_message_to_L1"))," syscall. The message parameters (which contain the recipient contract on L1 and the relevant data) are then attached to the relevant state update that includes this syscall invocation."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"}," let (message_payload : felt*) = alloc()\nassert message_payload[0] = <payload_parameter>\n// potentially add more elements to message_payload (message_payload[1], message_payload[2],  etc.)\n\nassert_lt_felt(to_address, ETH_ADDRESS_BOUND)\nassert_not_zero(to_address)\nsend_message_to_l1(to_address=to_address, payload_size=1, payload=message_payload)\n")),(0,r.kt)("p",null,"After the state update that included this transaction is proved and the L1 state is updated, the hash of the message is stored on L1 in the StarkNet Core Contract (and the relevant counter is increased), and the ",(0,r.kt)("inlineCode",{parentName:"p"},"LogMessageToL1")," event (which contains the message parameters) is emitted."),(0,r.kt)("p",null,"Later, the recipient address on L1 can access and consume the message as part of an L1 transaction by re-supplying the message parameters. This is done by calling ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/starkware-libs/cairo-lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/StarknetMessaging.sol#L119"},(0,r.kt)("inlineCode",{parentName:"a"},"consumeMessageFromL2"))," in the StarkNet Core Contract, who verifies that the hash corresponds to a stored message and that the caller is indeed the recipient on L1. In such a case, the reference count of the message hash in the StarkNet Core Contract decreases by 1."),(0,r.kt)("p",null,"The above flow is illustrated in the following diagram:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"l2l1",src:a(1529).Z})),(0,r.kt)("h2",{id:"l1--l2-message-cancellation"},"L1 \u2192 L2 Message Cancellation"),(0,r.kt)("p",null,"Imagine a scenario where a user transfers an asset from L1 to L2. The flow starts with the user sending the asset to a StarkNet bridge and the corresponding L1\u2192L2 message generation. Now, imagine that the L2 message consumption doesn\u2019t function (this might happen due to a bug in the dApps\u2019s Cairo contract). This could result in the user losing custody over their asset forever."),(0,r.kt)("p",null,"To mitigate this risk, we allow the contract that initiated the L1\u2192L2 message to cancel it \u2013 after declaring the intent and waiting a suitable amount of time. The user starts by calling ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/starkware-libs/cairo-lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/StarknetMessaging.sol#L134"},(0,r.kt)("inlineCode",{parentName:"a"},"startL1ToL2MessageCancellation"))," with the relevant message parameters in the StarkNet Core Contract. Then, after a five days delay, the user can finalize the cancellation by calling ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/starkware-libs/cairo-lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/StarknetMessaging.sol#L147"},(0,r.kt)("inlineCode",{parentName:"a"},"cancelL1ToL2Message")),". The reason for the delay is to protect the sequencer from a DOS attack in the form of repeatedly sending and canceling a message \u2013 before it is included in L1, rendering the L2 block which contains the activation of the corresponding L1 handler invalid. Note that this flow should only be used in edge cases such as bugs on the Layer 2 contract preventing message consumption."))}m.isMDXComponent=!0},3457:function(e,t,a){t.Z=a.p+"assets/images/l1l2-46916f5faaad1e4f132c6095a3b5e434.png"},1529:function(e,t,a){t.Z=a.p+"assets/images/l2l1-59d9b4f60a66a3b53476f3c058288f84.png"}}]);