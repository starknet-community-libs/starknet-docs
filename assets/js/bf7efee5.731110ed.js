"use strict";(self.webpackChunkstarknet_docs=self.webpackChunkstarknet_docs||[]).push([[37],{3905:function(n,t,e){e.d(t,{Zo:function(){return u},kt:function(){return m}});var r=e(7294);function a(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function o(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,r)}return e}function c(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?o(Object(e),!0).forEach((function(t){a(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):o(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function s(n,t){if(null==n)return{};var e,r,a=function(n,t){if(null==n)return{};var e,r,a={},o=Object.keys(n);for(r=0;r<o.length;r++)e=o[r],t.indexOf(e)>=0||(a[e]=n[e]);return a}(n,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(r=0;r<o.length;r++)e=o[r],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(a[e]=n[e])}return a}var i=r.createContext({}),p=function(n){var t=r.useContext(i),e=t;return n&&(e="function"==typeof n?n(t):c(c({},t),n)),e},u=function(n){var t=p(n.components);return r.createElement(i.Provider,{value:t},n.children)},l={inlineCode:"code",wrapper:function(n){var t=n.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(n,t){var e=n.components,a=n.mdxType,o=n.originalType,i=n.parentName,u=s(n,["components","mdxType","originalType","parentName"]),f=p(e),m=a,y=f["".concat(i,".").concat(m)]||f[m]||l[m]||o;return e?r.createElement(y,c(c({ref:t},u),{},{components:e})):r.createElement(y,c({ref:t},u))}));function m(n,t){var e=arguments,a=t&&t.mdxType;if("string"==typeof n||a){var o=e.length,c=new Array(o);c[0]=f;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=n,s.mdxType="string"==typeof n?n:a,c[1]=s;for(var p=2;p<o;p++)c[p]=e[p];return r.createElement.apply(null,c)}return r.createElement.apply(null,e)}f.displayName="MDXCreateElement"},4053:function(n,t,e){e.r(t),e.d(t,{frontMatter:function(){return s},contentTitle:function(){return i},metadata:function(){return p},toc:function(){return u},default:function(){return f}});var r=e(7462),a=e(3366),o=(e(7294),e(3905)),c=["components"],s={},i="Contract ABI",p={unversionedId:"Contracts/contract-abi",id:"Contracts/contract-abi",title:"Contract ABI",description:"Contract ABI is a representation of a StarkNet contract's interface. It is formatted as a JSON and describes the functions, structs and events which are defined in the contract.",source:"@site/docs/Contracts/contract-abi.md",sourceDirName:"Contracts",slug:"/Contracts/contract-abi",permalink:"/starknet-docs/docs/Contracts/contract-abi",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Contracts/contract-abi.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Commands",permalink:"/starknet-docs/docs/CLI/commands"},next:{title:"Contract Address",permalink:"/starknet-docs/docs/Contracts/contract-address"}},u=[],l={toc:u};function f(n){var t=n.components,e=(0,a.Z)(n,c);return(0,o.kt)("wrapper",(0,r.Z)({},l,e,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"contract-abi"},"Contract ABI"),(0,o.kt)("p",null,"Contract ABI is a representation of a StarkNet contract's interface. It is formatted as a JSON and describes the functions, structs and events which are defined in the contract."),(0,o.kt)("p",null,"You can get the contract's ABI by compiling:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"starknet-compile contract.cairo \\\n    --output contract_compiled.json \\\n    --abi contract_abi.json\n")),(0,o.kt)("p",null,"The following is an example contract ABI:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "members": [\n      {\n        "name": "x",\n        "offset": 0,\n        "type": "felt"\n      },\n      {\n        "name": "y",\n        "offset": 1,\n        "type": "felt"\n      }\n    ],\n    "name": "Point",\n    "size": 2,\n    "type": "struct"\n  },\n  {\n    "members": [\n      {\n        "name": "x",\n        "offset": 0,\n        "type": "felt"\n      },\n      {\n        "name": "p",\n        "offset": 1,\n        "type": "Point"\n      }\n    ],\n    "name": "Test",\n    "size": 3,\n    "type": "struct"\n  },\n  {\n    "data": [\n      {\n        "name": "a",\n        "type": "felt"\n      },\n      {\n        "name": "b",\n        "type": "felt"\n      }\n    ],\n    "keys": [],\n    "name": "status_update",\n    "type": "event"\n  },\n  {\n    "inputs": [\n      {\n        "name": "a_len",\n        "type": "felt"\n      },\n      {\n        "name": "a",\n        "type": "felt*"\n      }\n    ],\n    "name": "constructor",\n    "outputs": [],\n    "type": "constructor"\n  },\n  {\n    "inputs": [\n      {\n        "name": "user",\n        "type": "felt"\n      }\n    ],\n    "name": "extend_range",\n    "outputs": [],\n    "type": "function"\n  },\n  {\n    "inputs": [\n      {\n        "name": "points_len",\n        "type": "felt"\n      },\n      {\n        "name": "points",\n        "type": "(felt, Point, Point)*"\n      }\n    ],\n    "name": "input_arrays",\n    "outputs": [],\n    "type": "function"\n  },\n  {\n    "inputs": [\n      {\n        "name": "nested_len",\n        "type": "felt"\n      },\n      {\n        "name": "nested",\n        "type": "Test*"\n      }\n    ],\n    "name": "input_nested_arrays",\n    "outputs": [\n      {\n        "name": "res",\n        "type": "felt"\n      }\n    ],\n    "type": "function"\n  },\n  {\n    "inputs": [\n      {\n        "name": "array_len",\n        "type": "felt"\n      },\n      {\n        "name": "array",\n        "type": "felt*"\n      }\n    ],\n    "name": "output_arrays",\n    "outputs": [\n      {\n        "name": "array_len",\n        "type": "felt"\n      },\n      {\n        "name": "array",\n        "type": "felt*"\n      }\n    ],\n    "type": "function"\n  },\n  {\n    "inputs": [\n      {\n        "name": "points",\n        "type": "(Point, Point)"\n      }\n    ],\n    "name": "input_output_struct",\n    "outputs": [\n      {\n        "name": "res",\n        "type": "Point"\n      }\n    ],\n    "type": "function"\n  }\n]\n')))}f.isMDXComponent=!0}}]);